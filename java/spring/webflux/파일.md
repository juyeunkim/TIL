# 파일 등록

- WebFlux 를 사용할때는 MultiPartFile 을 사용하기보다는 FilePart 를 사용한다.
  
  - Mono 나 Flux 로 감싸서 사용
    
  - MultiPartFile 을 이용해서 포스트맨으로 테스트시
    
    - 400 BAD_REQUEST "Required MultipartFile parameter 'file' is not present"
      
    - 리액터 내부에서 헤더를 가져오는데, `multipart/form-data` 의 값을 null 로 가져온다.
      
    - [java - Spring Webflux 415 with MultipartFile - Stack Overflow](https://stackoverflow.com/questions/49457761/spring-webflux-415-with-multipartfile)
      

## 공부할때 도움이 되었던 사이트

[Upload a File with WebClient](https://www.baeldung.com/spring-webclient-upload-file)

[Multipart Support · Spring WebFlux By Example](https://hantsy.github.io/spring-reactive-sample/web/multipart.html)

[spring-reactive-sample/multipart at master · hantsy/spring-reactive-sample · GitHub](https://github.com/hantsy/spring-reactive-sample/tree/master/multipart)

[webflux-multipart-file-upload](https://medium.com/@eaimanshoshi/step-by-step-procedure-of-spring-webflux-multipart-file-upload-and-read-each-line-without-saving-it-6a12be64f6ee)

[GitHub - eaiman-shoshi/MultipartFileUpload: https://medium.com/@eaimanshoshi/step-by-step-procedure-of-spring-webflux-multipart-file-upload-and-read-each-line-without-saving-it-6a12be64f6ee](https://github.com/eaiman-shoshi/MultipartFileUpload)

## 파일을 다른 서버로 전송

> 목표 : 서버A ---> 서버B 사이에 파일을 전송하고 싶다.

### Mono<FilePart> 형태

- 서버 A

```java
@PostMapping(value = "/accounts/{accountId}/credentials")
    public Mono<String> uploadCredentials(
            @PathVariable("accountId") String accountId,
            @RequestPart("file") Mono<FilePart> file,
            @RequestPart("credentials") ReqGameCredentials credentials
    ){

        if(credentials.getClientId() == null) credentials.setClientId(accountId);
        return accountService.uploadCredentials(credentials, file);
    }
```

```java
public Mono<String> uploadCredentials(ReqGameCredentials credentials, Mono<FilePart> file) {
        return webClient().zipWith(projectService.loadById(credentials.getPid()))
                .flatMap(tp -> {
                    Map<String, String> pathVariable = new HashMap<>();
                    pathVariable.put("gameCode", tp.getT2().getPkey());
                    pathVariable.put("channel", credentials.getChannel());

                    return file
                            .flatMap(filePart ->
                                    tp.getT1().post()
                                    .uri(API_VERSION + "/admin/games/{gameCode}/channels/{channel}/credentials", pathVariable)
                                    .body(BodyInserters.fromMultipartData("credential", filePart))
//                                        .body(BodyInserters.fromPublisher(filePart.content(), DataBuffer.class))
                                    .exchangeToMono(response -> {
                                        if(response.statusCode().equals(HttpStatus.OK)){
                                            return response.bodyToMono(String.class);
                                        }else{
                                            return response.createException().flatMap(Mono::error);
                                        }
                                    }))
                            ;
                });
    }
```

- 서버 B

```java
@PostMapping("/games/{gameCode}/channels/{channel}/credentials")
    @Transactional
    public Mono<String> uploadCredentials(@PathVariable("gameCode") String gameCode
            , @PathVariable("channel") String channel
            , @RequestPart("credential") Mono<FilePart> filePartMono
    ) {
        /////
    }
```

### Flux<FilePart> 형태

- 서버 A

```java
@PostMapping("/filePartFlux")
        Mono<String> filePartsFlux(@RequestPart("fileParts") Flux<FilePart> parts) {
            return partFluxDescription(parts);
        }
```

```java
// 1
private static Mono<String> partFluxDescription(Flux<? extends Part> partsFlux) {
        return partsFlux.collectList().map(MultipartIntegrationTests::partListDescription);
}


// 2
private static String partListDescription(List<? extends Part> parts) {
        return parts.stream().map(MultipartIntegrationTests::partDescription)
                .collect(Collectors.joining(",", "[", "]"));
}

// 3
private static String partDescription(Part part) {
        return part instanceof FilePart ? part.name() + ":" + ((FilePart) part).filename() : part.name();
    }
```

> 1. Flux<FilePart> ->
>   
> 2. List<FilePart> ->
>   
> 3. fileName 만을 추출해서 (["fileParts: fileName"] ,) 형태로 리턴
>   

- 서버 B

```java
Mono<String> result = webClient
                .post()
                .uri("/filePartFlux")
                .bodyValue(generateBody())
                .retrieve()
                .bodyToMono(String.class);

        StepVerifier.create(result)
                .consumeNextWith(body -> assertThat(body).isEqualTo("[fileParts:foo.txt,fileParts:logo.png]"))
                .verifyComplete();
```

```java
private MultiValueMap<String, HttpEntity<?>> generateBody() {
        MultipartBodyBuilder builder = new MultipartBodyBuilder();
        builder.part("fieldPart", "fieldValue");
        builder.part("fileParts", new ClassPathResource("foo.txt", MultipartHttpMessageReader.class));
        builder.part("fileParts", new ClassPathResource("logo.png", getClass()));
        builder.part("jsonPart", new Person("Jason"));
        return builder.build();
    }
```

> 서버 A 의 fileParts 의 값을 세팅해준다.
> 
> 이때, classPath 에 등록된 파일을 넣어주는데,
> 
> > 이렇게 하려면 Multipart 형태와 같은 값을 넣어줘야하지않을까?
> 
> 내가 원하는 건 MultiValueMap 에 Flux<FilePart> 형태의 값을 넣어주는것을 원함.
> 
> > - 해결 방법
> > 
> > List<FilePart> 의 형태를 받아서 `MultipartBodyBuilder` 에 넣어주고,
> > 
> > ```java
> > .body(BodyInserters.fromMultipartData(bodyBuilder.build()))
> > ```
> > 
> > ```java
> > MultipartBodyBuilder bodyBuilder = new MultipartBodyBuilder();
> >                     for (FilePart filePart: credentials.getFiles()) {
> >                         bodyBuilder.part("credential", filePart)
> > 
> >         }
> > ```

## 에러 유형

```
[org.springframework.core.codec.CodecException: No suitable writer found for part
```

> .body(BodyInserters.fromMultipartAsyncData("credential", files, FilePart.class))
> 
> 을 통해서 Flux<FilePart> 의 값을 전달하였는데 에러 발생
